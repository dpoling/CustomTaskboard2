<!DOCTYPE html>
<html>
<head>
    <title>Custom Task Board</title>

    <script type="text/javascript" src="/apps/2.1/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                (function () {
    console.log('Inside Column Settings Grid Function');
    Ext.define('Rally.apps.kanban.columnSettngsComp', {
        extend: 'Ext.form.field.Base',
        alias: 'widget.kanbancolumnsettngscomp',
        fieldSubTpl: '<div id="{id}" class="settings-grid"></div>',
        width: 600,
        cls: 'column-settings',
        config: {
            value: undefined
        },

        onDestroy: function () {
            if (this._grid) {
                this._grid.destroy();
                delete this._grid;
            }
            this.callParent(arguments);
        },

        onRender: function () {
            console.log("inside onRender");
            this.callParent(arguments);
//            var decodedValue = this.value;
//            console.log('decodedValue= ', decodedValue);
//            if (Ext.isString(decodedValue)) {
//                decodedValue = Ext.JSON.decode(decodedValue);
//            }
            this._store = Ext.create('Ext.data.Store', {
                fields: ['column', 'display', 'mapping'],
                data: []
            });
            this._buildGrid();
        },
        _buildGrid: function () {
            console.log("inside buildGrid", this._store);
            if (this._grid) {
                this._grid.destroy();
            }
            this._grid = Ext.create('Rally.ui.grid.Grid', {
                width: 600,
                renderTo: this.inputEl,
                showPagingToolbar: false,
                showRowActionsColumn: false,
                enableRanking: false,
                columnCfgs: this._getColumnCfgs(),
                minHeight: 122,
                maxHeight: 132,
                scroll: true,
                store: this._store,
                handlesEvents: {
                    fieldselected: function (field) {
                        //console.log('inside field selected event handler');
                        //Change the grid to contain rows for the new field
                        field.getAllowedValueStore().load({
                            callback: function (records) {
                                var data = [];
                                Ext.Array.each(records, function (r) {
                                    if (r.get('StringValue') && r.get('StringValue').length > 0) {
                                        data.push(this._recordToGridRow(r));
                                    }
                                }, this);
                                console.log('data is: ', data);
                                //var data = Ext.Array.map(records, this._recordToGridRow, this);
                                this._store.loadRawData(data);
                            },
                            scope: this
                        });
                    }
                }
            });
        },
        _getColumnCfgs: function () {
            var ynStore = Ext.create('Rally.data.custom.Store', {
                fields: ['name', 'value'],
                data: [
                    {name: "No", value: false},
                    {name: "Yes", value: true}
                ]
            });
            var columns = [
                {
                    text: 'Column',
                    dataIndex: 'column',
                    emptyCellText: 'None',
                    flex: 2
                },
                {
                    text: 'Display',
                    dataIndex: 'display',
                    width: 75,
                    xtype: 'templatecolumn',
                    tpl: Ext.create('Rally.ui.renderer.template.BooleanTemplate', {
                        fieldName: 'display'
                    }),
                    editor: {
                        xtype: 'rallycombobox',
                        store: ynStore,
                        displayField: 'name',
                        valueField: 'value'
                    }
                },
                {
                    text: 'Task State Mapping',
                    dataIndex: 'mapping',
                    emptyCellText: '--No Mapping--',
                    flex: 2,
                    editor: {
                        xtype: 'rallyfieldvaluecombobox',
                        model: Ext.identityFn('Task'),
                        field: 'State',
                        listeners: {
                            ready: function (combo) {
                                var noMapping = {};
                                noMapping[combo.displayField] = '--No Mapping--';
                                noMapping[combo.valueField] = '';
                                combo.store.insert(0, [noMapping]);
                            }
                        }
                    }
                }
            ];
            console.log("inside getColumnCfgs", columns);
            return columns;
        },
        _recordToGridRow: function (allowedValue) {
            var columnName = allowedValue.get('StringValue');
            //Look to see if the grid has data in it (_store is the grid's data stor)
            //If the store is empty, pref will be null, else pref will have the last set of column defs
            var pref = this._store.getCount() === 0 ? null : this.getSetting('columnDefs');
            var row = null;
            console.log('recordToGridRow ', columnName, this._store.getCount());
            console.log('columnDefs: ', this.getSetting('columnDefs'));
            console.log("Pref: ", pref);
            // look for the same row in the pref's
            if (pref) {
                row = _.find(pref, function (row) {
                    return row.column === columnName;
                });
                console.log('Row is: ', row);
            }
            // if the row isn't found in the prefs, create a default row
            if (!row) {
                row = {
                    column: columnName,
                    display: true,
                    mapping: ''
                };
            }
            return row;
        },
        getSubmitData: function () {
            var data = {};
            data[this.name] = Ext.JSON.encode(this._getData());
            return data;
        },
        _getData: function () {
            var setting = [];
            this._store.each(function (record) {
                var row = {};
                row['column'] = record.get('column');
                row['display'] = record.get('display');
                row['mapping'] = record.get('mapping');
                setting.push(row);
            });
            return setting;
        },
        getErrors: function () {
            var errors = [];
            if (this._store && !Ext.Object.getSize(this._getData())) {
                errors.push('At least one column must be shown.');
            }
            return errors;
        },
        setValue: function (value) {
            this.callParent(arguments);
            this._value = value;
        }
    });
})();


                Ext.define('CustomApp', {
    extend: 'Rally.app.App',
    componentCls: 'app',
    config: {
        defaultSettings: {
            myQuery: '',
            groupByField: 'State',
            columnDefs: [
                {column: 'Defined', display: true, mapping: 'Defined'},
                {column: 'In-Progress', display: true, mapping: 'In-Progress'},
                {column: 'Completed', display: true, mapping: 'Completed'}
            ]
        }
    },
    launch: function () {
        console.log('settings', this.getSettings());
        this._addBoard();
    },
    _addBoard: function () {
        console.log('_addBoard');
        this.add({
            xtype: 'rallycardboard',
            types: ['Task'],
            attribute: 'State',
            context: this.getContext(),
            rowConfig: {
                field: 'WorkProduct'
            },
            storeConfig: {
                filters: this._getFilters()
            }
        });
        console.log('after adding the board');
    },
    _removeBoard: function () {
        var board = this.down('rallycardboard');
        if (board) {
            this.remove(board);
        }
    },
    _getFilters: function () {
        var tbScope = this.getContext().getTimeboxScope();
        var qFilter = this.getSetting('myQuery');
        if (tbScope) {
            var tbFilter = tbScope.getQueryFilter();
            if (qFilter && qFilter.length > 0) {
                return tbFilter.and(Rally.data.wsapi.Filter.fromQueryString(qFilter));
            } else {
                return tbFilter;
            }
        } else {
            if (qFilter && qFilter.length > 0) {
                return Rally.data.wsapi.Filter.fromQueryString(qFilter);
            } else {
                return [];
            }
        }
    },
    onTimeboxScopeChange: function (timeboxScope) {
        this.getContext().setTimeboxScope(timeboxScope);
        this._removeBoard();
        this._addBoard();
    },
    getSettingsFields: function () {
//        var parent = this;
//        var _columnDefsStore = Ext.create('Ext.data.Store', {
//            fields: ['column', 'display', 'mapping'],
//            data: []
//        });
        console.log('In getSettingsFields');
        return [
            {
                name: 'groupByField',
                xtype: 'rallyfieldcombobox',
                model: Ext.identityFn('Task'),
                margin: '0 0 0 0',
                fieldLabel: 'Columns',
                listeners: {
                    ready: function (combo) {
                        combo.store.filterBy(function (record) {
                            var attr = record.get('fieldDefinition').attributeDefinition;
                            return attr && !attr.ReadOnly && attr.Constrained && "STRING" === attr.AttributeType;
                        });
                    },
                    select: function (combo) {
                        console.log('select listener activated');
                        this.fireEvent('fieldselected', combo.getRecord().get('fieldDefinition'));
                    }
                },
                bubbleEvents: ['fieldselected', 'fieldready']
            },
            {
                name: 'columnDefs',
                fieldLabel: 'Column Definitions',
                xtype: 'kanbancolumnsettngscomp',
                margin: '2 0 0 0',
                width: 600
            },
            {
                xtype: 'textareafield',
                name: 'myQuery',
                margin: '2px 0 0 0',
                width: 680,
                fieldLabel: 'Custom Query',
                labelAlign: 'left',
                validateOnChange: false,
                validateOnBlur: false,
                validator: function (value) {
                    try {
                        if (value && value.length) {
                            Rally.data.wsapi.Filter.fromQueryString(value);
                        }
                    } catch (e) {
                        Rally.ui.notify.Notifier.showError({message: e.message});
                        console.log("message", e.message);
                        return e.message;
                    }
                    return true;
                }
            }
        ];
    },
    _getColumnCfgs: function () {
        var ynStore = Ext.create('Rally.data.custom.Store', {
            fields: ['name', 'value'],
            data: [
                {name: "No", value: false},
                {name: "Yes", value: true}
            ]
        });
        var columns = [
            {
                text: 'Column',
                dataIndex: 'column',
                emptyCellText: 'None',
                flex: 200
            },
            {
                text: 'Display',
                dataIndex: 'display',
                width: 75,
                xtype: 'templatecolumn',
                tpl: Ext.create('Rally.ui.renderer.template.BooleanTemplate', {
                    fieldName: 'display'
                }),
                editor: {
                    xtype: 'rallycombobox',
                    store: ynStore,
                    displayField: 'name',
                    valueField: 'value'
                }
            },
            {
                text: 'Task State Mapping',
                dataIndex: 'mapping',
                emptyCellText: '--No Mapping--',
                flex: 3,
                editor: {
                    xtype: 'rallyfieldvaluecombobox',
                    model: Ext.identityFn('Task'),
                    field: 'State',
                    listeners: {
                        ready: function (combo) {
                            var noMapping = {};
                            noMapping[combo.displayField] = '--No Mapping--';
                            noMapping[combo.valueField] = '';
                            combo.store.insert(0, [noMapping]);
                        }
                    }
                }
            }
        ];
        return columns;
    },
    _recordToGridRow: function (allowedValue, store) {
        var columnName = allowedValue.get('StringValue');
        var pref = store.getCount() === 0 ? null : this.getSetting('columnDefs');
        var row = null;
        console.log('recordToGridRow ', columnName, store.getCount());
        console.log('columnDefs: ', this.getSetting('columnDefs'));
        console.log("Pref: ", pref);
        if (pref) {
            row = _.find(pref, function (row) {
                return row.column === columnName;
            });
            console.log('Row is: ', row);
        }
        if (!row) {
            row = {
                column: columnName,
                display: true,
                mapping: ''
            };
        }
        return row;
    }

});


            Rally.launchApp('CustomApp', {
                name:"Custom Task Board",
	            parentRepos:""
            });

        });
    </script>



    <style type="text/css">
        .app {
  /* Add app styles here */
}

    </style>
</head>
<body>
</body>
</html>
